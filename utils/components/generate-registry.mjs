#!/usr/bin/env node

import { readdir, writeFile, stat } from 'fs/promises';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const COMPONENTS_DIR = join(__dirname, '../../src/cms/components');
const OUTPUT_FILE = join(__dirname, '../../src/cms/components/_component-registry.ts');

/**
 * Scans the components directory and generates a registry with dynamic imports
 */
async function generateComponentRegistry() {
    try {
        console.log('ðŸ” Scanning components directory...');
        
        const componentDirs = await readdir(COMPONENTS_DIR);
        const components = [];
        
        for (const dir of componentDirs) {
            // Skip non-directory files and private files
            if (dir.startsWith('_') || dir.startsWith('.')) {
                continue;
            }
            
            const dirPath = join(COMPONENTS_DIR, dir);
            const dirStat = await stat(dirPath);
            
            if (!dirStat.isDirectory()) {
                continue;
            }
            
            // Look for the main .astro component file
            const files = await readdir(dirPath);
            const astroFile = files.find(file => {
                if (!file.endsWith('.astro') || file.startsWith('_')) {
                    return false;
                }
                
                // Main component file typically matches the directory name (without 'Component' suffix)
                const expectedName = dir.replace(/Component$/, '');
                const fileName = file.replace('.astro', '');
                
                return fileName === expectedName || fileName === dir.replace(/Component$/, '');
            });
            
            if (astroFile) {
                // Extract component name from directory (remove 'Component' suffix if present)
                const componentName = dir.replace(/Component$/, '');
                const fileName = astroFile.replace('.astro', '');
                
                components.push({
                    name: componentName,
                    fileName,
                    dir,
                    filePath: `./${dir}/${astroFile}`
                });
                
                console.log(`âœ… Found component: ${componentName} (${astroFile})`);
            }
        }
        
        // Generate the registry TypeScript file
        const registryContent = generateRegistryCode(components);
        
        await writeFile(OUTPUT_FILE, registryContent, 'utf8');
        
        console.log(`ðŸŽ‰ Generated component registry with ${components.length} components`);
        console.log(`ðŸ“ Registry written to: ${OUTPUT_FILE}`);
        
        return components;
        
    } catch (error) {
        console.error('âŒ Error generating component registry:', error);
        process.exit(1);
    }
}

/**
 * Generates the TypeScript code for the component registry
 */
function generateRegistryCode(components) {
    const imports = components.map(comp => 
        `  '${comp.name}': () => import('${comp.filePath}')`
    ).join(',\n');
    
    const typeUnion = components.map(comp => `'${comp.name}'`).join(' | ');
    
    return `// This file is auto-generated by utils/components/generate-registry.mjs
// Do not edit manually - run "bun run components:generate" to regenerate

import type { ContentPayload } from '../../graphql/shared/ContentPayload';

export type ComponentType = ${typeUnion};

export interface ComponentProps {
  contentPayload: ContentPayload;
  data: any;
  displaySettings?: any;
  displayTemplateKey?: string;
}

export type ComponentImporter = () => Promise<{ default: any }>;

/**
 * Component registry with dynamic imports
 * Maps component type names to their dynamic import functions
 */
export const componentRegistry: Record<ComponentType, ComponentImporter> = {
${imports}
};

/**
 * Available component types
 */
export const availableComponents: ComponentType[] = [
  ${components.map(comp => `'${comp.name}'`).join(',\n  ')}
];

/**
 * Dynamically loads and renders a component by type
 */
export async function loadComponent(componentType: string): Promise<any> {
  const normalizedType = componentType as ComponentType;
  
  if (!componentRegistry[normalizedType]) {
    console.warn(\`Unknown component type: \${componentType}\`);
    return null;
  }
  
  try {
    const componentModule = await componentRegistry[normalizedType]();
    return componentModule.default;
  } catch (error) {
    console.error(\`Failed to load component \${componentType}:\`, error);
    return null;
  }
}

/**
 * Check if a component type is available in the registry
 */
export function isValidComponentType(componentType: string): componentType is ComponentType {
  return componentType in componentRegistry;
}
`;
}

// Run the generator if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
    generateComponentRegistry();
}

export { generateComponentRegistry };